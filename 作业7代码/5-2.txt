#include<stdio.h>
#include<curses.h>
#include<signal.h>
#include<unistd.h>
#include<sys/time.h>

#define BLANK " "
#define SNAKE "ooo~>"
#define FOOD '&'
#define WALLEN 60
#define WALWID 20

struct snake
{	
	int srow,scol;
	//struct SNake* next;
}S[20];

char head='>';
char neck='~';
int rdir=0;
int cdir=1;
int slen=5;

char food[3]={'&','+','-'};
int splevel=8;//speed level

int walltop=0;
int wallbot=WALWID+1;
int wallleft=5;
int wallright=WALLEN+6;

int foodrow;
int foodcol;
int foodi;

int delay=300;

int total=0;
int istart=0;
int score=0;

void on_alarm(int);
void setwall();
void setfood();
int isover(int,int);


int main()
{
	int c;
	for(int i=0;i<slen;i++)
	{
		S[i].scol=i;
		S[i].srow=1;
	}
		
	initscr();
	//crmode();
	//noecho();
	clear();
	mvaddstr(1,0,SNAKE);
	setwall();
	setfood();
	move(LINES-1,COLS-1);
	refresh();
	
	signal(SIGALRM,on_alarm);
	set_ticker(delay);
	while((c=getchar())!='Q')
	{
		
		if(istart!=1)
			continue;		
		if(c=='w'&&rdir!=1)
		{
			rdir=-1;
			cdir=0;
			head='^';
		}
		else if(c=='s'&&rdir!=-1)
		{
			rdir=1;
			cdir=0;
			head='@';
		}
		else if(c=='a'&&cdir!=1)
		{
			rdir=0;
			cdir=-1;
			head='<';
		}
		else if(c=='d'&&cdir!=-1)
		{
			rdir=0;	
			cdir=1;
			head='>';
		}
		total++;
	}
	endwin();
	printf("Cogratulation!\nYou get %d scores\n",score);
	return 0;
}

void setwall()
{
	for(int i=walltop;i<=wallbot;i++)
	{
		mvaddch(i,wallleft,'=');
		mvaddch(i,wallright,'=');
	}
	for(int j=wallleft+1;j<=wallright-1;j++)
	{
		mvaddch(walltop,j,'=');
		mvaddch(wallbot,j,'=');
	}
	mvaddch(1,wallleft,' ');
}

void setfood()
{
	srand((unsigned int)time(NULL));
	foodcol=rand()%WALLEN+6;
	foodrow=rand()%WALWID+1;
	foodi=rand()%3;
	mvaddch(foodrow,foodcol,food[foodi]);
}

int isover(int newcol,int newrow)
{
	int over=0;
	if(newcol<=wallleft||newcol>=wallright||newrow<=walltop||newrow>=wallbot)//collase the wall
		over=1;
	else 
	{
		for(int i=0;i<slen;i++)
		{
			if(S[i].srow==newrow&&S[i].scol==newcol)//collase self
				over=1;
		}
	}
	return over;
}
	

void on_alarm(int signum)
{
	signal(SIGALRM,on_alarm);
	int speed=1;
	int newcol=S[slen-1].scol+cdir;
	int newrow=S[slen-1].srow+rdir;
	if(istart==0&&S[0].scol>5){
		mvaddch(1,5,'=');
		istart=1;
	}
	else if(istart==1&&isover(newcol,newrow)==1)
	{
		mvaddstr((walltop+wallbot)/2,70,"Game Over!");
		move(LINES-1,COLS-1);
		refresh();
		signal(SIGALRM,SIG_IGN);//stop	
		return;	
	}
	if(S[slen-1].scol+cdir==foodcol&&S[slen-1].srow+rdir==foodrow)
	{
		if(foodi==0)
		{
			S[slen].scol=newcol;
			S[slen].srow=newrow;
			foodcol=-1;
			foodrow=-1;
			slen++;
			score++;
			speed=0;
		}
		else if(foodi==1)//speed up
		{
			foodcol=-1;
			foodrow=-1;
			if(delay>=200){//can't less than 100
				delay-=100;
				splevel++;
				set_ticker(delay);
			}
		}
		else if(foodi==2)//speed down
		{
			foodcol=-1;
			foodrow=-1;
			if(delay<=900){//can't more than 1000
				delay+=100;
				splevel--;
				set_ticker(delay);
			}
		}
	}
	else if(speed==1)
	{
		mvaddch(S[0].srow,S[0].scol,' ');
		for(int i=0;i<slen-1;i++)
		{
			S[i].scol=S[i+1].scol;
			S[i].srow=S[i+1].srow;
		}
		S[slen-1].scol=newcol;
		S[slen-1].srow=newrow;
	}
	mvaddch(S[slen-1].srow,S[slen-1].scol,head);
	mvaddch(S[slen-2].srow,S[slen-2].scol,neck);
	mvaddch(S[slen-3].srow,S[slen-3].scol,'o');
	if(foodcol==-1&&foodrow==-1)
		setfood();
	mvprintw((walltop+wallbot)/2-6,70,"score: %d",score);
	mvprintw((walltop+wallbot)/2-4,70,"length: %d",slen);
	mvprintw((walltop+wallbot)/2-2,70,"level: %d",splevel);
	move(LINES-1,COLS-1);
	refresh();
}
		
		


set_ticker( n_msecs )
{
        struct itimerval new_timeset;
        long    n_sec, n_usecs;

        n_sec = n_msecs / 1000 ;
        n_usecs = ( n_msecs % 1000 ) * 1000L ;

        new_timeset.it_interval.tv_sec  = n_sec;        /* set reload  */
        new_timeset.it_interval.tv_usec = n_usecs;      /* new ticker value */
        new_timeset.it_value.tv_sec     = n_sec  ;      /* store this   */
        new_timeset.it_value.tv_usec    = n_usecs ;     /* and this     */

	return setitimer(ITIMER_REAL, &new_timeset, NULL);
}