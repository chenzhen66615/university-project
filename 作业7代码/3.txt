/*  bounce2d 1.0	
 *	bounce a character (default is 'o') around the screen
 *	defined by some parameters
 *
 *	user input: 	s slow down x component, S: slow y component
 *		 	f speed up x component,  F: speed y component
 *			Q quit
 *
 *	blocks on read, but timer tick sends SIGALRM caught by ball_move
 *	build:   cc bounce2d.c set_ticker.c -lcurses -o bounce2d
 */

#include	<curses.h>
#include	<signal.h>
#include	<sys/time.h>
#include	<string.h>
#include	"bounce.h"

struct ppball the_ball ;

/**  the main loop  **/

//baffer length = 6
int btop=TOP_ROW+5;//baffer top
int bbot=BOT_ROW-5;//baffer bottom
int brows[20];//save baffer rows

void set_up();
void wrap_up();
void add_wall_baffle();
void mv_baffle(char);


int main()
{
	int	c;
	
	//add_wall_baffle();
	set_up();
	
	while ( ( c = getchar()) != 'Q' ){
		if( c=='w'||c=='s') mv_baffle(c);
  		else if ( c == 'f' ) the_ball.x_ttm--;
		else if ( c == 's' ) the_ball.x_ttm++;
		else if ( c == 'F' ) the_ball.y_ttm--;
		else if ( c == 'S' ) the_ball.y_ttm++;
	}

	wrap_up();
}

void add_wall_baffle()
{
	int i,j=0;
	for(i=LEFT_EDGE;i<=RIGHT_EDGE;i++)
		mvaddstr(TOP_ROW-1,i,"=");
	for(i=TOP_ROW-1;i<=BOT_ROW+1;i++)
		mvaddstr(i,LEFT_EDGE-1,"=");
	for(i=LEFT_EDGE;i<=RIGHT_EDGE;i++)
		mvaddstr(BOT_ROW+1,i,"=");
	memset(brows,0,sizeof(brows));
	for(i=btop;i<=bbot;i++){
		brows[i]=1;//the row of baffer is 1
		mvaddstr(i,RIGHT_EDGE+1,"=");
	}
}

void mv_baffle(char input)
{
	int i;
	if(input=='w')
	{
		mvaddstr(bbot,RIGHT_EDGE+1," ");
		brows[bbot]=0;
		btop--;
		bbot--;
		brows[btop]=1;
	}
	else if(input=='s')
	{
		mvaddstr(btop,RIGHT_EDGE+1," ");
		brows[btop]=0;
		btop++;
		bbot++;
		brows[bbot]=1;
	}
	mvaddstr(btop,RIGHT_EDGE+1,"=");
	mvaddstr(bbot,RIGHT_EDGE+1,"=");
}

void set_up()
/*
 *	init structure and other stuff
 */
{
	void	ball_move(int);

	the_ball.y_pos = Y_INIT;
	the_ball.x_pos = X_INIT;
	the_ball.y_ttg = the_ball.y_ttm = Y_TTM ;
	the_ball.x_ttg = the_ball.x_ttm = X_TTM ;
	the_ball.y_dir = 1  ;
	the_ball.x_dir = 1  ;
	the_ball.symbol = DFL_SYMBOL ;

	initscr();
	noecho();
	crmode();
	clear();
	add_wall_baffle();//add dangban//
	signal( SIGINT , SIG_IGN );
	mvaddch( the_ball.y_pos, the_ball.x_pos, the_ball.symbol  );
	mvaddstr(2,29,"ROW:5~20     COL:10~70");
	move(LINES-1,COLS-1);
	refresh();
	
	signal( SIGALRM, ball_move );
	set_ticker( 1000 / TICKS_PER_SEC );	/* send millisecs per tick */
}

void wrap_up()
{

	set_ticker( 0 );
	endwin();		/* put back to normal	*/
}


void ball_move(int signum)
{
	int	y_cur, x_cur, moved;
	int	out=0;
	signal( SIGALRM , SIG_IGN );		/* dont get caught now 	*/
	y_cur = the_ball.y_pos ;		/* old spot		*/
	x_cur = the_ball.x_pos ;
	moved = 0 ;

	if ( the_ball.y_ttm > 0 && the_ball.y_ttg-- == 1 ){
		the_ball.y_pos += the_ball.y_dir ;	/* move	*/
		the_ball.y_ttg = the_ball.y_ttm  ;	/* reset*/
		moved = 1;
	}

	if ( the_ball.x_ttm > 0 && the_ball.x_ttg-- == 1 ){
		the_ball.x_pos += the_ball.x_dir ;	/* move	*/
		the_ball.x_ttg = the_ball.x_ttm  ;	/* reset*/
		moved = 1;
	}

	if ( moved ){
		mvaddch( y_cur, x_cur, BLANK );
		//mvaddch( y_cur, x_cur, BLANK );
		mvaddch( the_ball.y_pos, the_ball.x_pos, the_ball.symbol );
		if(bounce_or_lose( &the_ball )==0 && the_ball.x_pos>RIGHT_EDGE+1)
		{
			out=1;
			mvaddstr(12,33,"The ball is out");
			signal(SIGALRM,SIG_IGN);
		}
		move(LINES-1,COLS-1);
		refresh();
		mvaddstr((TOP_ROW+BOT_ROW)/2,(LEFT_EDGE+RIGHT_EDGE)/2,"                 ");
	}
	if(out!=1)
	{
		signal( SIGALRM, ball_move);		/* for unreliable systems */
	}

}

int bounce_or_lose(struct ppball *bp)
{
	int	return_val = 0 ;

	if ( bp->y_pos == TOP_ROW ){
		bp->y_dir = 1 ; 
		return_val = 1 ;
	} else if ( bp->y_pos == BOT_ROW ){
		bp->y_dir = -1 ;
	       	return_val = 1;
	}
	if ( bp->x_pos == LEFT_EDGE ){
		bp->x_dir = 1 ;
	       	return_val = 1 ;
	} else if ( bp->x_pos == RIGHT_EDGE ){
		if(brows[bp->y_pos]==1){
			bp->x_dir = -1;
	       		return_val = 1;
		}
		else{
			return_val=0;//0 is fly out of RIGHT_EDGE
		}
	}

	return return_val;
}

set_ticker( n_msecs )
{
        struct itimerval new_timeset;
        long    n_sec, n_usecs;

        n_sec = n_msecs / 1000 ;
        n_usecs = ( n_msecs % 1000 ) * 1000L ;

        new_timeset.it_interval.tv_sec  = n_sec;        /* set reload  */
        new_timeset.it_interval.tv_usec = n_usecs;      /* new ticker value */
        new_timeset.it_value.tv_sec     = n_sec  ;      /* store this   */
        new_timeset.it_value.tv_usec    = n_usecs ;     /* and this     */

	return setitimer(ITIMER_REAL, &new_timeset, NULL);
}